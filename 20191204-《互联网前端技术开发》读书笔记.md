####  JSON

JSON 是 JavaScript Object Notation 的缩写，它是一种数据交换格式。在 JSON 出现以前，大家一直用 XML来传递数据。在2002年道格拉斯·克罗克福特发明了 JSON 这种轻量级的数据交换格式。他设计的 JSON 实际上是 JavaScript 的一个子集。

把任何 JavaScript 对象变成 JSON，就是把这个对象序列化(stringfy()方法)成一个 JSON 格式的字符串，这样才能通过网络传递给其他计算机。如果收到一个 JSON 格式的字符串，只需要把它反序列化成一个 JavaScript 对象，就可以在 JavaScript 中直接使用这个对象了。

序列化即将对象的状态信息转化为可以存储或传输的形式过程。其作用是在使用的时候，将其当前状态写入到临时或持久性存储区以后，可以通过从存储区中读取或反序列化对象的状态，重新创建该对象。通常情况下，对象实例的所有字段都会被序列化，由此可见数据会被表示为实例的序列化数据。以下举例说明：把小明这个对象序列化成 JSON 格式的字符串。

```js
'use strict'
var student = {
    name:'小明',
    age:14,
    gender:true,
    height:1.65,
    grade:null,
    'middle-school':'Beijing Middle School',
    skills:['HTML','Java','C++','React']
};
```

按缩进输出：

```js
JSON.stringfy(student,null,'  '); // 序列化的方法 stringfy()
```

序列化结果：

```json
{
    "name":"小明",
    "age":14,
    "gender":true,
    "height":1.65,
    "grade":null,
    "middle-school":"Beijing Middle School",
    "skills":[
    	"HTML",
    	"Java",
    	"C++",
    	"React"
    ]
}
```

第二个参数用于如何控制筛选对象的键值，如果只需要输出指定的属性，可以传入array，如下：

```js
JSON.stringfy(student,["name","skills"],'  ');
```

序列化结果：

```json
{
    "name":"小明",
    "skills":[
    	"HTML",
    	"Java",
    	"C++",
    	"React"
    ]
}
```

同样可以传入一个函数，这样对象的每个键值对都会被函数先处理：

```js
function convert(key,value) {
    if(typeof value === "string") {
        return value.toUpperCase();
    }
    return value;
}
JSON.stringfy(student,conver,'	');
```

以上的代码把所有属性值都变成了大写：

```json
{
    "name":"小明",
    "age":14,
    "gender":true,
    "height":1.65,
    "grade":null,
    "middle-school":"BEIJING MIDDLE SCHOOL",
    "skills":[
    	"HTML",
    	"Java",
    	"C++",
    	"REACT"
    ]
}
```

如果要精确控制如何序列化小明，可以给student定义一个 toJSON() 的方法，直接返回 JSON 应该序列化的数据：

```js
var student = {
    name:'小明',
    age:14,
    gender:true,
    height:15,
    grade:null,
    'middle-scholl':'Beijing Middle School',
    skills:['HTML','Java','C++','React'],
    toJSON:function() {
        return { // 只输出 name 和 age,并且改变了 key
            'Name':this.name,
            'Age':this.age
        };
    }
};
JSON.stringfy(student);// '{"Name":"小明","Age":"14"}'
```

反序列化的概念和作用与序列化正好相反，即把 JSON格式的数据恢复为对象的过程，就叫作对象的反序列化。用一个实例解释：拿到一个 JSON 格式的字符串，直接用  JSON.parse() 把它变成一个 Java Script 对象。

```js
JSON.parse('[1,2,3,true]'); // [1,2,3,true]
JSON.parse('{"name":"小明","age":14}'); // {name:"小明",age:14}
JSON.parse('true'); // true
JSON.pare('123.45');// 123.45
```

#### 面向对象编程

面向对象的编程，本质是建立模型体现出来的抽象思维过程和面向对象的方法为基础进行编程开发。通常会涉及类、对象、实例等基本概念。其中，类是对象的类型模板，是对事物共有规律的一个抽象，如定义Student类来表示学生，类本身是一种类型，Student表示学生类型，但不表示具体的某个学生；实例是根据类创建的对象，如根据Student类可以创建出xiaoming、xiaohong等多个实例，每个实例表示一个具体的学生，他们全都属于 Student 类型。

#### 面向对象编程基础

JavaScript 不区分类和实例的概念，而是通过原型来实现面向对象编程的。原型是指当需要创建 xiaoming 这个具体的学生时，当前并没有一个 Student 类型可用。但是有一个现成的对象可以使用，示例代码如下：

```js
var robot = {
	name:'Robot',
	height:1.6,
	run:function() {
		console.log(this.name + "is running...");
	}
};
```

可以看出这个 robot 对象有名字、身高，还会跑，有点像 xiaoming，即以此为基础修改，把它改名为 Student，然后创建xiaoming:

```js
var Student = {
    name:'Robot',
	height:1.2,
	run:function() {
		console.log(this.name + "is running...");
	}
};
var xiaoming = {
    name:"小明"
};
xiaoming.__proto__ = Student;
```

可以看到最后一行代码把 xiaoming 的原型指向了对象 Student。

```js
xiaoming.name;// "小明"
xiaoming.run();// 小明 is running...
```

小明有自己的 name 属性，但并没有定义 run 方法。不过，由于 xiaoming 是从 Student 继承而来的，只要 Student 有 run()方法， xiaoming 也可以调用。 由此可见，JavaScript 的原型链和 Java 的 Class 区别在于，它没有 "Class" 的概念，所有的对象都是实例，所以继承关系的本质就是一个对象的原型指向另一个对象。例如，把 xiaoming 的原型指向其他对象：

```js
var Bird = {
    fly:function() {
        console.log(this.name + "is flying ...");
    }
};
xiaoming.__proto__ = Bird;
```

现在 xiaoming 已经无法 run()了，因为在程序中已经将 xiaoming 从 Student 变为 Bird 对象了。

#### 创建对象

JavaScript 对每个创建对象都会设置一个原型，指向其原型对象。当用 object.xxx 访问一个对象的属性时， JavaScript 引擎会先在当前对象上查找该属性，如果没有找到，就到其原型对象上找；如果还没找到，就一直上溯到 Object.prototype 对象；最后如果还没有找到，就只能返回 undefined。例如，创建一个 Array 对象：

```js
var arr = [1,2,3]; // 其原型链： arr ----> Array.prototype ----> Object.prototype ----> null
```

Array.prototype 定义 indexOf(), shift() 等方法，因此可以在所有 array 对象上直接调用这些方法。当创建一个函数(函数对象)时：

```js
function() {return 0;} // 其原型链： foo ----> Function.prototype ----> Object.prototype ----> null
```

除了{ ... }创建一个对象外，JavaScript 还可以用构造函数的方法来创建对象，首先要定义一个构造函数:

```js
function Student(name) {
    this.name = name;
    this.hello = function () {
        console.log('Hello' + this.name + '!');
    }
}
```

在 JavaScript 中，构造函数用关键字 new 来调用这个函数，并返回一个对象：

```js
var xiaoming = new Student('小明');
xiaoming.name; // "小明"
xiaoming.hello(); // Hello,小明!
```

在上述代码中如果不写 new ,则该函数就是一个普通函数，它返回 undefined。但是，如果使用了关键字 new ，它就变成了一个构造函数，绑定的 this 指向新创建的对象，并默认返回 this，也就不需要在最后写 return this；。新创建的 xiaoming 的原型链：

```js
xiaoming ----> Student.prototype ----> Object.prototype -----> nulll
```

用 new Student() 创建的对象还从原型上获得了一个 constructor 属性，它指向函数 Student本身：

```js
xiaoming.constructor === Student.prototype.constructor;  // true
Student.prototype.constructor === Student; // true
Object.getPrototypeOf(xiaoming) === Student.prototype; // true
xiaoming instanceof Student; // true
```

如果一个函数被定义为用于创建对象的构造函数，但是调用时缺少调用函数 new , 则在 strict 模式下， this.name = name 将报错，因为 this 绑定为 undefined。 在非 strict 模式下，this.name = name 不报错，因为 this 绑定为 window。于是无意间创建了全局变量 name, 并且返回 undefined。为了防止这种错误，一种方法是通过工具如 jslint 进行检测；另一种方法就是进行内部封装，例如使用 createStudent() 函数，在内部封装所有的 new 操作:

```js
function Student(props) {
    this.name = props.name || '匿名'; // 默认值为 '匿名'
    this.grade = props.grade || 1 ; // 默认值为 1
}

Student.prototype.hello = function() {
    alert('Hello' + this.name + '!');
};

function createStudent(props) {
    return new Student(props||{})
}
```

由此可以看出，createStudent() 函数有两个优点: 一是不需要 new 来调用； 二是参数传递非常灵活。

```js
var xiaoming = createStudent({
    name:'小明'
});
xiaoming.grade; // 1
```

所以如果创建的对象有很多属性，可以按需传递属性，剩余的属性用默认值。由于参数是一个Object，所以不用记忆参数的顺序。

#### 原型继承

JavaScript 中