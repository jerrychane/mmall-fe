### MDF整体框架原理

### 1.整体设计

整个MDF架构遵循以下三大原则：

- 前端 (client) 遵循MVVM框架，开发者面向ViewModel编程；
- 服务端 (node) 有koa2的middlewares提供请求转发、UI元数据数据处理、生成js代码等；
- 整个框架工程由 koa2脚手架 + 运行时框架包 (yxyweb) 组成；

### 2.client 架构

#### 2.1 设计原则

**核心思想：**

- MVVM + 模型驱动开发；
- viewmodel作为编程模型，所有可编程操作的对象均为viewmodel。小到一个组件、大到一个UI模板均为一个viewmodel对象；
- XX_xx_xxx.VM.extend.js为扩展页面UI模板的扩展文件，即写扩展代码的地方；
- 在extend文件里只能通过当前页面的viewmodel对象来获取和操作页面UI交互(View)和业务数据(Model);
- web和mobile采用同一套viewmodel,故此web、移动、大屏等多端的编程模型相同；

当不知道组件是哪种ViewModel时，可以默认为SimpleModel或者ContainerModel；

列表实际上为GridModel, 是对列表的一种的抽象，并不是说只有列表才可以用，其他的组件也可以用， 其中GridModel包含了许多列，每一列都可以受元数据控制。 例如制作一个卡片、列表，如果需要一些数据，这些数据是一个List的数据结构。

viewmodel实际上指的是整个页面，而model指的是业务数据层，viewmodel包含了model层。主要的viewmodel包含billViewModel(表单级) 、voucherlist(单据列表)、voucher(单据详情)、freeview、filterViewModel(查询方案)、referViewModel(参照模态框)、RoleViewModel(角色)。所以，单据列表和单据详情是两个对象；freeview是扩展业务数据的对象。

### 3. 扩展开发-级联参照开发

#### 3.1.以省市参照联动扩展为例

- 新建一个文件名为AA_enterprise_VM.Extend.js放到omc_test_web/src/client/business/AA目录下；
- 里面init函数内代码如下:

```js
init: function (viewmodel) {
    // 在城市参照弹出之前，获取省参照的value,通过setFilter将value存放到过滤条件中(在城市参照获取城市列表)
    viewmodel.get("bankcity").on('beforeBrowse',function(data) {
        var provinceValue;
        if(viewmodel.get("bankprovince").getValue()) {
            cb.utils.alert("请选择开户省");
            return false
        }else{
            provinceValue = viewmodel.get("bankprovince").getValue();
        }
        var condition = {
            "isRefreshData":true,
            "parentId":provinceValue,
            "province":provinceValue
        };
        this.setFilter(condition);
    } );
    // 如果省参照的值有变化，就将城市参照的值清空
    viewmodel.get("bankprovince").on('afterValueChange',function(data){
        viewmodel.get("bankcity").setValue(null);
    });
}
```

注:

"bankcity"为城市选择参照的字段名称(excel表中对应的cFieldName ); 

"bankprovince" 为省选择参照的字段名称, provinceValue为获取的省选择参照的id。

模板内所有字段名称可在omc_test_web/autogenererate/viewmodel/AA 下自定生成对应的渲染模板js文件

### 4. FreeView扩展

#### 4.1 核心思想

**MDD框架负责UI模板渲染，业务数据请求加载交给开发者。**

**具体含义为:**

- 在扩展文件中使用api实现业务数据加载，如果是列表，通过列表的GridModel的setDataSource来加载数据；
- UIMeta负责将页面渲染出来；
- 使用extend.js调用平台API来做数据加载；
- viewmodel自动将数据更新到react组件；

#### 4.2 示例代码

```js
cb.define(['common/common_VM.Extend.js'],function(common) {
    var PU_pu_pursettlemanualmenu_VM_Extend = {
        doAction:function(name,viewmodel) {
            if(this[name]) {
                this[name](viewmodel);
            },
        init:function(viewmodel) {
            var bFilter = false;
            viewmodel.on('filterClick',function(data) {
                if(bFilter) {
                    viewmodel.get('pu_pursettlemanualmenu_rd').setDataSource(
                        {url:'/bill/list',method:'POST'},
                        {billnum:'pu_pursettlemanualmenu_rd',condition:data.condition}    
                    );
                    viewmodel.get('pu_pursettlemanualmenu_fp').setDataSource(
                        {url:'/bill/list',method:'POST'},
                        {billnum:'pu_pursettlemanualmenu_fp',condition:data.condition}    
                    );
                }else{
                    bFilter = true;
                }
            });
            viewmodel.on("settle",function(args) {
                var datard = viewmodel.get('pu_pursettlemanualmenu_rd').getSelectedRows();
                var datafp = viewmodel.get('pu_pursettlemanualmenu_fp').getSelectedRows();
                var data = {rd:datard,fp:datafp};
                var callback = viewmodel.getParams().callback;
                callback(data);
                viewmodel.communication({type:'return'});
            });
            },        
        }
    };
    try {
        module.exports = PU_pu_pursettlemanualmenu_VM_Extend;
    }catch(error){
        
    }
    return PU_pu_pursettlemanualmenu_VM_Extend;
});
```



